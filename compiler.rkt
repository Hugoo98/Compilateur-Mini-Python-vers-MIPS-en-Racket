
;;Le code suivant consiste à traduire les instructions du langage source en instructions mips
#lang racket/base

(require racket/match)

(require "ast.rkt" "lexer.rkt" "parser.rkt")

(provide mips-data program-eval mips-exit main text data-eval data mips-function)

;;Compilation tout d'abord les fonction pour mettre leurs instructions avant le main du mips
(define (mips-function program envrmnt)
  (match program
   ((list expr)
    (for-each mips-emit
     (match expr
				((Pfunc id args instr) 
                               (label (comp id envrmnt 0))
                               (mips-compile (list instr) envrmnt)
                               (list (J 'ra))) 
				((Pbool v)             '())
				((Pval v)              '())
				((Pid n)               '())
				((Pdef id v)           '())
				((Pcond test yes no)   '())
				((Ploop test instr)    '())
				((Pprint expr)         '())
				((Pprint_op expr)      '())
				((Pnot op v)           '())
        ((Pfuncall id args)    '())
        ((Pprint_var expr)     '())
        ((Pret ex)             '())
				((Pop op v1 v2)        '()))))
    ((cons expr1 expr2)  (mips-function (list expr1) envrmnt) (mips-function expr2 envrmnt))))

;;Vérification de nombre d'instructions qui composent chaque programme
(define (program-eval program envrmnt)
  (match program
    ((list expr)         (mips-compile program envrmnt))
    ((cons expr1 expr2)  (mips-compile (list expr1) envrmnt) (program-eval expr2 envrmnt))))

;;Définir les data des expressions
(define (data-eval program envrmnt)
  (match program 
   ((list expr) 
     (match expr 
        ((Pfuncall id args)  '())
        ((Pfunc id args expr) (match-data (list expr) envrmnt))
        ((Pdef id v)          (match-data program envrmnt))
        ((Pbool v)            (match-data program envrmnt))
        ((Pval v)             (match-data program envrmnt))
        ((Pid n)              (match-data program envrmnt))
        ((Pdef id v)          (match-data program envrmnt))
        ((Pcond test yes no)  (match-data program envrmnt))
        ((Ploop test instr)   (match-data program envrmnt))
        ((Pprint expr)        (match-data program envrmnt))
        ((Pprint_op ex)       (match-data program envrmnt))
        ((Pprint_var ex)      (match-data program envrmnt))
        ((Pnot op v)          (match-data program envrmnt))
        ((Pret expr)          (match-data (list expr) envrmnt))
        ((Pop op v1 v2)       (match-data program envrmnt))))
        ((cons expr1 expr2)   (match-data (list expr1) envrmnt) (data-eval expr2 envrmnt))))

;;Afficher les instructions mips de la fin de chaque programme 
(define (mips-exit)
  (printf "li $v0, 4\nla $a0, nl\nsyscall\nli $v0, 10\nsyscall\n"))
 
;;Compilation des expressions et les opérations
(define (comp program envrmnt fp-sp) 
  (match program
     ((Pbool b)              (if b 1 0)) 
     (#f                     0)
     (#t                     1)
     ((Pval v)               v)
     ((Pid name)             name)
     ((Pdef id expr)         (comp expr envrmnt fp-sp)) 
     ((Pcond test yes no)    (hash-set envrmnt (comp test envrmnt fp-sp) (comp yes envrmnt fp-sp) (comp no envrmnt fp-sp)))
     ((Ploop test instr)     (hash-set envrmnt (comp test envrmnt fp-sp) (comp instr envrmnt fp-sp)))
     ((Pprint expr)          (hash-set envrmnt (comp expr envrmnt fp-sp)))
     ((Pfargs ex)             'a0)
     ((Pnot op v)            ('not (comp (not (comp v envrmnt fp-sp)) envrmnt fp-sp)))
     ((Pop op v1 v2)         (match op
                                ('add (+  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('sub (-  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('mul (*  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('div (/  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('exp (expt (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('sup (>  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('inf (<  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('seq (>= (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('ieq (<= (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('eq  (=  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('neq (=  (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('mod (modulo (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('and (and (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))
                                ('or  (or (comp v1 envrmnt fp-sp) (comp v2 envrmnt fp-sp)))))))
       
;;Matcher les instructions mips
(define (mips-emit instr)
  (match instr
    ((Move rd rs)   (printf "move $~a, $~a\n" rd rs))
    ((Li r i)       (printf "li $~a, ~a\n" r i))
    ((La r a)       (printf "la $~a, ~a\n" r (mips-loc a)))
    ((Addi rd rs i) (printf "addi $~a, $~a, ~a\n" rd rs i))
    ((Add rd rs r)  (printf "add $~a, $~a, $~a\n" rd rs r))
    ((Sub rd rs i)  (printf "sub $~a, $~a, ~a\n" rd rs i))
    ((Mult r1 r2)   (printf "mult $~a, $~a\n" r1 r2))
    ((Div r1 r2)    (printf "div $~a, $~a\n" r1 r2))
    ((Mflo rs)      (printf "mflo $~a\n" rs))
    ((Mfhi rs)      (printf "mfhi $~a\n" rs))
    ((Sw r loc)     (printf "sw $~a, ~a\n" r (mips-loc loc)))
    ((Lw r loc)     (printf "lw $~a, ~a\n" r (mips-loc loc)))
    ((Syscall)      (printf "syscall\n"))
    ((Jr r)         (printf "jr $~a\n" r))
    ((J r)          (printf "j $~a\n" r))
    ((Jal r)        (printf "jal ~a\n" r))
    ((Beq r1 r2 lbl)(printf "beq $~a, $~a, ~a\n" r1 r2 lbl))
    ((Bgt r1 r2 lbl)(printf "bgt $~a, $~a, ~a\n" r1 r2 lbl))
    ((Blt r1 r2 lbl)(printf "blt $~a, $~a, ~a\n" r1 r2 lbl))
    ((Bge r1 r2 lbl)(printf "bge $~a, $~a, ~a\n" r1 r2 lbl))
    ((Ble r1 r2 lbl)(printf "ble $~a, $~a, ~a\n" r1 r2 lbl))
    ((And rd r1 r2) (printf "and $~a, $~a, $~a\n"rd r1 r2))
    ((Or rd r1 r2)  (printf "or $~a, $~a, $~a\n"rd r1 r2))
    ((Xor rd r1 r2) (printf "xor $~a, $~a, $~a\n"rd r1 r2))
    ((B lbl)        (printf "b ~a\n" lbl))
    ((Label l)      (printf "~a:\n" l))))

;;Matcher les labels et les emplacements dans la pile
(define (mips-loc loc)
  (match loc
    ((Lbl l)   (format "~a" l))
    ((Mem b r) (format "~a($~a)" b r))))

;;Fonction d'affichage utilisée au début du programme 
(define (data)
   (printf"\n.DATA\n"))

;;Charger des chaines de char dans un .data
(define (mips-data data)
  (hash-for-each data
     (lambda (k v)
	     (if (number? v)
           (printf "~a: .word ~s\n" k v)
           (printf "~a: .asciiz ~s\n" k v)))))

;;Afficher les informations nécessaires pour le programme mips
(define (text)
  (printf ".TEXT\n.globl main\n"))
(define (main)
  (printf "MAIN:\n"))



;;la fonction print-data qui sert à charger la chaîne de char mise dans le print dans le .data
(define (print-data data)
  (hash-for-each data
    (lambda (k v)
      (printf "~a: .asciiz \"~s\"\n" k v))))

;;Les fonctions  utilisées pour les instructions de if et while
(define (mips-beq)   (printf "beq $v0, $0, Else\n"))
(define (mips-label) (printf "b Endif\nElse:\n"))
(define (mips-loop)  (printf "loop:\nbeq $v0, $0, end_loop\n"))
(define (mips-bloop) (printf "b loop\n"))

;;la fonction mips_condition match les programme que peut contenir un if ou while
(define (mips_condition program envrmnt)
 (for-each mips-emit 
  (append
   (match program
     ((list (Pbool v))     (append (list (Li 'v0 (comp v envrmnt 0)))))
     ;;un numero
     ((list (Pval v))      (append (list (Li 'v0 v))))
     ;;déclaration de variable
     ((list (Pdef id v))          (append (list (Lw 't0 (Lbl 'val)))))
     ;;print
     ((list (Pprint expr)) (append (list (Li 'v0 4))
                                   (list (La 'a0 (Lbl (comp expr envrmnt 0))))
                                   (list (Syscall))
                                   (list (Li 'v0 4))
                                   (list (La 'a0 (Lbl 'nl)))
								                   (list (Syscall))))

    ;;afficher des opérations ,chiffres ...
    ((list (Pprint_op expr))
     (list (mips-compile (list expr) envrmnt))
     (append (list (Li 'v0 4))
             (list (La 'a0 (Lbl 'nl)))
					   (list (Syscall))))

  ;;afficher la valeur d'une varaible
  ((list (Pprint_var expr)) (append (list (Lw 'a0 (Lbl (comp expr envrmnt 0))))
                                    (list (Li 'v0 4))
                                    (list (Syscall))))
   ;;retour de fonction
    ((Pret expr)        (mips_condition (list expr) envrmnt))

   ;;definition de fonctions
 			((list (Pfunc id args expr))  '())
    ;;Definition des opérations(arithmétiques, logiques, de comparaison)
    ((list (Pop op v1 v2))
        (match op 
          ('add (append (list (Li 't0 (comp v1 envrmnt 0))) 
		                    (list (Addi 'v0 't0 (comp v2 envrmnt 0)))))
          ('sub (append (list (Li 't0 (comp v1 envrmnt 0)))
					              (list (Sub 'v0 't0 (comp v2 envrmnt 0)))))
					('mul (append (list (Li 't0 (comp v1 envrmnt 0)))
											  (list (Li 't1 (comp v2 envrmnt 0)))
												(list (Mult 't0 't1))
												(list (Mflo 's0))
										    (list (Add 'v0 'zero 's0))))
				  ('div (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Div 't0 't1))
												(list (Mflo 's0))
												(list (Add 'v0 'zero 's0))))
          ('mod (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Div 't0 't1))
												(list (Mfhi 's0))
												(list (Add 'v0 'zero 's0))))

          ('and (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
                        (list (And 'v0 't0 't1))))
          ('or  (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
                        (list (Or 'v0 't0 't1))))
                        
					('sup (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Bgt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('inf (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Blt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('seq (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Bge 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
					('ieq (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Ble 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
											  (list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('eq  (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Beq 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('neq (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
											  (list (Beq 't0 't1 'FALSE))
												(list (B 'TRUE))
												(list (Label 'FALSE))
                        (list (Li 'v0 0))
												(list (B 'next))
                        (list (Label 'TRUE))
                        (list (Li 'v0 1))
                        (list (Label 'next)))))))))) 

;;afficher les .data qui correspond au instructions du programme
(define (match-data program envrmnt)
 (append 
    (match program
      ((list (Pbool v))              '())
      ((list (Pnot op v))            '())
      ((list (Pval v))               '())
      ((list (Pfunc id args instr))  (match-data (list instr) envrmnt))
      ((list (Pid n))                (list (mips-data (make-hash '((n . "\nError: le nom entré est nom défini\n"))))))
      ((list (Pdef id v))            (mips-data (hash (comp id envrmnt 0) (comp v envrmnt 0))))
      ((list (Pop op v1 v2))         '())
      ((list (Pprint expr))           (print-data (hash (comp expr envrmnt 0) (comp expr envrmnt 0))))
      ((list (Pcond test yes no)) 
                                     (match-data (list test) envrmnt)
       													     (match-data (list yes) envrmnt)
       													     (match-data (list no) envrmnt))
      ((list (Ploop test instr)) 
                                     (match-data (list test) envrmnt)
       													     (match-data (list instr) envrmnt))
     ((list (Pprint_op expr))        (match-data (list expr) envrmnt))
     ((list (Pfuncall id args))      '())
    ((list (Pprint_var expr))       (match-data (list expr) envrmnt)))))

;;Affectation de chaque argument d'une fonction  au registre $a qui lui correspond
(define (func-args expr envrmnt n)
  (match expr
    ((list (Pid a))  (hash-set envrmnt a n))
    ((cons a b)      ((hash-set envrmnt a n) (func-args (list b) envrmnt (+ n 1))))))
(define (label l) (printf "~a :\n" l))
;;traduction des expressions en instructions mips
(define (mips-compile program envrmnt)
 (for-each mips-emit 
   (append
    (match program
      ((list (Pbool v))   (append (list (Li 'v0 1))
                                  (list (La 'a0 (Lbl (comp v envrmnt 0))))
                                  (list (Syscall)))) 
      ;; Affichage après la compilation (cas ou le code entré est un numéro)
      ((list (Pval v))    (append  (list (Li 'v0 1))
                                   (list (La 'a0 (Lbl v)))
                                   (list (Syscall)))) 
               
      ;; ou bien un caractère ou une chaine de caractères mais cela envoie un message d'erreur pcq le 'char' ou "chaine de c" entré n'est pas identifié
      ((list (Pid n))     (append (list (Li 'v0 4))
                                  (list (La 'a0 (Lbl 'n)))
                                  (list (Syscall))))              
                                         
      ;;definition des variables 
      ((list (Pdef id v))        (append (list (Lw 't0 (Lbl (comp id envrmnt 0))))))

			;;Definition de la fonction
 			((list (Pfunc id args expr))  '())

      ;;Appel à la fonction 
      ((list (Pfuncall id args))     (append (list (Jal (comp id envrmnt 0))))) 

      ;;Les valeurs retournées de la fonction 
      ((list (Pret expr))        (mips_condition (list expr) envrmnt)
                                  (list (Li 't9 1)))

      ;; La condition if (yes or no)
      ((list (Pcond test yes no))   
        (mips_condition (list test) envrmnt)
        (mips-beq)
        (mips_condition (list yes) envrmnt)
        (mips-label)
        (mips_condition (list no) envrmnt)
        (list (Label 'Endif)))
    
     ;;La boucle while
     ((list (Ploop test instr))
       (mips_condition (list test) envrmnt)
       (mips-loop)
       (mips_condition (list instr) envrmnt)
       (mips-bloop)
       (list (Label 'end_loop)))

       
      ;;affichage de ('expr')
      ((list (Pprint expr))
        (append (list (Li 'v0 4))
                (list (La 'a0 (Lbl (comp expr envrmnt 0))))
                (list (Syscall))
                (list (Li 'v0 4))
                (list (La 'a0 (Lbl 'nl)))
								(list (Syscall))))
      
      ;;Affichage des variables et les operations  ...
      ((list (Pprint_op expr))
        (list (mips-compile (list expr) envrmnt))
        (append (list (Li 'v0 4))
                (list (La 'a0 (Lbl 'nl)))
								(list (Syscall)))) 
		
      ;;les arguments d'une fonction 
      ((list (Pfargs id))
      (list (Move 't0 'a0)))

      ;;affichage de la valeur d'une variable
      ((list (Pprint_var expr)) (append (list (Lw 'a0 (Lbl (comp expr envrmnt 0))))
                                        (list (Li 'v0 1))
                                        (list (Syscall))))


       ;;Affichage de l'operation logique not
       ((list (Pnot op v)) (append (list (Li 't0 (comp v envrmnt 0)))
												           (list (Li 't1 1))
                                   (list (Xor 'a0 't0 't1))
                                   (list (Li 'v0 1))
												           (list (Syscall)))) 
      ;; affichage des operations (arithmétiques , logiques et de la comparaison)                              
	    ((list (Pop op v1 v2))
        (match op 
          ('add (append (if (number? (comp v1 envrmnt 0)) (list (Li 't0 (comp v1 envrmnt 0))) '())
		                    (list (Addi 't0 't0 (comp v2 envrmnt 0)))
				                (list (Li 'v0 1))
				                (list (Move 'a0 't0))						         
                        (list (Syscall))))
          ('sub (append (list (Li 't0 (comp v1 envrmnt 0)))
					              (list (Sub 't0 't0 (comp v2 envrmnt 0)))
				                (list (Li 'v0 1))
				                (list (Move 'a0 't0))
										    (list (Syscall))))
					('mul (append (list (Li 't0 (comp v1 envrmnt 0)))
											  (list (Li 't1 (comp v2 envrmnt 0)))
												(list (Mult 't0 't1))
												(list (Mflo 's0))
                        (list (Li 'v0 1))
										    (list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
				  ('div (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Div 't0 't1))
												(list (Mflo 's0))
                        (list (Li 'v0 1))
												(list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
          ('exp (append (list (Li 'a0 (comp (Pop op v1 v2) envrmnt 0)))
                        (list (Li 'v0 1))
                        (list (Syscall))))
					('sup (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Bgt 't0 't1 'supTRUE))
												(list (B 'supFALSE))
												(list (Label 'supTRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'supnext))
                        (list (Label 'supFALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'supnext))))
          ('inf (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Blt 't0 't1 'infTRUE))
												(list (B 'infFALSE))
												(list (Label 'infTRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'infnext))
                        (list (Label 'infFALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'infnext))))
          ('seq (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Bge 't0 't1 'seqTRUE))
												(list (B 'seqFALSE))
												(list (Label 'seqTRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'seqnext))
                        (list (Label 'seqFALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'seqnext))))
					('ieq (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Ble 't0 't1 'ieqTRUE))
												(list (B 'ieqFALSE))
												(list (Label 'ieqTRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
											  (list (B 'ieqnext))
                        (list (Label 'ieqFALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'ieqnext))))
          ('eq  (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Beq 't0 't1 'eqTRUE))
												(list (B 'eqFALSE))
												(list (Label 'eqTRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'eqnext))
                        (list (Label 'eqFALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'eqnext))))
          ('neq (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
											  (list (Beq 't0 't1 'neqFALSE))
												(list (B 'neqTRUE))
												(list (Label 'neqFALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
												(list (B 'neqnext))
                        (list (Label 'neqTRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
                        (list (Label 'neqnext))))
          ('mod (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
												(list (Div 't0 't1))
												(list (Mfhi 's0))
                        (list (Li 'v0 1))
												(list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
          ('and (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
                        (list (And 't2 't0 't1))
                        (list (Li 'v0 1))
                        (list (Move 'a0 't2))
												(list (Syscall))))
          ('or  (append (list (Li 't0 (comp v1 envrmnt 0)))
												(list (Li 't1 (comp v2 envrmnt 0)))
                        (list (Or 't2 't0 't1))
                        (list (Li 'v0 1))
                        (list (Move 'a0 't2))
												(list (Syscall))))))))))
